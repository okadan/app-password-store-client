// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class Libgit2 {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Libgit2(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Libgit2.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  /// Set or query a library global option
  ///
  /// Available options:
  ///
  /// * opts(GIT_OPT_GET_MWINDOW_SIZE, size_t *):
  ///
  /// > Get the maximum mmap window size
  ///
  /// * opts(GIT_OPT_SET_MWINDOW_SIZE, size_t):
  ///
  /// > Set the maximum mmap window size
  ///
  /// * opts(GIT_OPT_GET_MWINDOW_MAPPED_LIMIT, size_t *):
  ///
  /// > Get the maximum memory that will be mapped in total by the library
  ///
  /// * opts(GIT_OPT_SET_MWINDOW_MAPPED_LIMIT, size_t):
  ///
  /// > Set the maximum amount of memory that can be mapped at any time
  /// > by the library
  ///
  /// * opts(GIT_OPT_GET_MWINDOW_FILE_LIMIT, size_t *):
  ///
  /// > Get the maximum number of files that will be mapped at any time by the
  /// > library
  ///
  /// * opts(GIT_OPT_SET_MWINDOW_FILE_LIMIT, size_t):
  ///
  /// > Set the maximum number of files that can be mapped at any time
  /// > by the library. The default (0) is unlimited.
  ///
  /// * opts(GIT_OPT_GET_SEARCH_PATH, int level, git_buf *buf)
  ///
  /// > Get the search path for a given level of config data.  "level" must
  /// > be one of `GIT_CONFIG_LEVEL_SYSTEM`, `GIT_CONFIG_LEVEL_GLOBAL`,
  /// > `GIT_CONFIG_LEVEL_XDG`, or `GIT_CONFIG_LEVEL_PROGRAMDATA`.
  /// > The search path is written to the `out` buffer.
  ///
  /// * opts(GIT_OPT_SET_SEARCH_PATH, int level, const char *path)
  ///
  /// > Set the search path for a level of config data.  The search path
  /// > applied to shared attributes and ignore files, too.
  /// >
  /// > - `path` lists directories delimited by GIT_PATH_LIST_SEPARATOR.
  /// >   Pass NULL to reset to the default (generally based on environment
  /// >   variables).  Use magic path `$PATH` to include the old value
  /// >   of the path (if you want to prepend or append, for instance).
  /// >
  /// > - `level` must be `GIT_CONFIG_LEVEL_SYSTEM`,
  /// >   `GIT_CONFIG_LEVEL_GLOBAL`, `GIT_CONFIG_LEVEL_XDG`, or
  /// >   `GIT_CONFIG_LEVEL_PROGRAMDATA`.
  ///
  /// * opts(GIT_OPT_SET_CACHE_OBJECT_LIMIT, git_object_t type, size_t size)
  ///
  /// > Set the maximum data size for the given type of object to be
  /// > considered eligible for caching in memory.  Setting to value to
  /// > zero means that that type of object will not be cached.
  /// > Defaults to 0 for GIT_OBJECT_BLOB (i.e. won't cache blobs) and 4k
  /// > for GIT_OBJECT_COMMIT, GIT_OBJECT_TREE, and GIT_OBJECT_TAG.
  ///
  /// * opts(GIT_OPT_SET_CACHE_MAX_SIZE, ssize_t max_storage_bytes)
  ///
  /// > Set the maximum total data size that will be cached in memory
  /// > across all repositories before libgit2 starts evicting objects
  /// > from the cache.  This is a soft limit, in that the library might
  /// > briefly exceed it, but will start aggressively evicting objects
  /// > from cache when that happens.  The default cache size is 256MB.
  ///
  /// * opts(GIT_OPT_ENABLE_CACHING, int enabled)
  ///
  /// > Enable or disable caching completely.
  /// >
  /// > Because caches are repository-specific, disabling the cache
  /// > cannot immediately clear all cached objects, but each cache will
  /// > be cleared on the next attempt to update anything in it.
  ///
  /// * opts(GIT_OPT_GET_CACHED_MEMORY, ssize_t *current, ssize_t *allowed)
  ///
  /// > Get the current bytes in cache and the maximum that would be
  /// > allowed in the cache.
  ///
  /// * opts(GIT_OPT_GET_TEMPLATE_PATH, git_buf *out)
  ///
  /// > Get the default template path.
  /// > The path is written to the `out` buffer.
  ///
  /// * opts(GIT_OPT_SET_TEMPLATE_PATH, const char *path)
  ///
  /// > Set the default template path.
  /// >
  /// > - `path` directory of template.
  ///
  /// * opts(GIT_OPT_SET_SSL_CERT_LOCATIONS, const char *file, const char *path)
  ///
  /// > Set the SSL certificate-authority locations.
  /// >
  /// > - `file` is the location of a file containing several
  /// >   certificates concatenated together.
  /// > - `path` is the location of a directory holding several
  /// >   certificates, one per file.
  /// >
  /// > Calling `GIT_OPT_ADD_SSL_X509_CERT` may override the
  /// > data in `path`.
  /// >
  /// > Either parameter may be `NULL`, but not both.
  ///
  /// * opts(GIT_OPT_ADD_SSL_X509_CERT, const X509 *cert)
  ///
  /// > Add a raw X509 certificate into the SSL certs store.
  /// > This certificate is only used by libgit2 invocations
  /// > during the application lifetime and is not persisted
  /// > to disk. This certificate cannot be removed from the
  /// > application once is has been added.
  /// >
  /// > - `cert` is the raw X509 cert will be added to cert store.
  ///
  /// * opts(GIT_OPT_SET_USER_AGENT, const char *user_agent)
  ///
  /// > Set the value of the comment section of the User-Agent header.
  /// > This can be information about your product and its version.
  /// > By default this is "libgit2" followed by the libgit2 version.
  /// >
  /// > This value will be appended to User-Agent _product_, which
  /// > is typically set to "git/2.0".
  /// >
  /// > Set to the empty string ("") to not send any information in the
  /// > comment section, or set to NULL to restore the default.
  ///
  /// * opts(GIT_OPT_GET_USER_AGENT, git_buf *out)
  ///
  /// > Get the value of the User-Agent header.
  /// > The User-Agent is written to the `out` buffer.
  ///
  /// * opts(GIT_OPT_SET_USER_AGENT_PRODUCT, const char *user_agent_product)
  ///
  /// > Set the value of the product portion of the User-Agent header.
  /// > This defaults to "git/2.0", for compatibility with other git
  /// > clients. It is recommended to keep this as git/<version> for
  /// > compatibility with servers that do user-agent detection.
  /// >
  /// > Set to the empty string ("") to not send any user-agent string,
  /// > or set to NULL to restore the default.
  ///
  /// * opts(GIT_OPT_GET_USER_AGENT_PRODUCT, git_buf *out)
  ///
  /// > Get the value of the User-Agent product header.
  /// > The User-Agent product is written to the `out` buffer.
  ///
  /// * opts(GIT_OPT_SET_WINDOWS_SHAREMODE, unsigned long value)
  ///
  /// > Set the share mode used when opening files on Windows.
  /// > For more information, see the documentation for CreateFile.
  /// > The default is: FILE_SHARE_READ | FILE_SHARE_WRITE.  This is
  /// > ignored and unused on non-Windows platforms.
  ///
  /// * opts(GIT_OPT_GET_WINDOWS_SHAREMODE, unsigned long *value)
  ///
  /// > Get the share mode used when opening files on Windows.
  ///
  /// * opts(GIT_OPT_ENABLE_STRICT_OBJECT_CREATION, int enabled)
  ///
  /// > Enable strict input validation when creating new objects
  /// > to ensure that all inputs to the new objects are valid.  For
  /// > example, when this is enabled, the parent(s) and tree inputs
  /// > will be validated when creating a new commit.  This defaults
  /// > to enabled.
  ///
  /// * opts(GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION, int enabled)
  ///
  /// > Validate the target of a symbolic ref when creating it.  For
  /// > example, `foobar` is not a valid ref, therefore `foobar` is
  /// > not a valid target for a symbolic ref by default, whereas
  /// > `refs/heads/foobar` is.  Disabling this bypasses validation
  /// > so that an arbitrary strings such as `foobar` can be used
  /// > for a symbolic ref target.  This defaults to enabled.
  ///
  /// * opts(GIT_OPT_SET_SSL_CIPHERS, const char *ciphers)
  ///
  /// > Set the SSL ciphers use for HTTPS connections.
  /// >
  /// > - `ciphers` is the list of ciphers that are eanbled.
  ///
  /// * opts(GIT_OPT_ENABLE_OFS_DELTA, int enabled)
  ///
  /// > Enable or disable the use of "offset deltas" when creating packfiles,
  /// > and the negotiation of them when talking to a remote server.
  /// > Offset deltas store a delta base location as an offset into the
  /// > packfile from the current location, which provides a shorter encoding
  /// > and thus smaller resultant packfiles.
  /// > Packfiles containing offset deltas can still be read.
  /// > This defaults to enabled.
  ///
  /// * opts(GIT_OPT_ENABLE_FSYNC_GITDIR, int enabled)
  ///
  /// > Enable synchronized writes of files in the gitdir using `fsync`
  /// > (or the platform equivalent) to ensure that new object data
  /// > is written to permanent storage, not simply cached.  This
  /// > defaults to disabled.
  ///
  /// opts(GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION, int enabled)
  ///
  /// > Enable strict verification of object hashsums when reading
  /// > objects from disk. This may impact performance due to an
  /// > additional checksum calculation on each object. This defaults
  /// > to enabled.
  ///
  /// opts(GIT_OPT_SET_ALLOCATOR, git_allocator *allocator)
  ///
  /// > Set the memory allocator to a different memory allocator. This
  /// > allocator will then be used to make all memory allocations for
  /// > libgit2 operations.  If the given `allocator` is NULL, then the
  /// > system default will be restored.
  ///
  /// opts(GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY, int enabled)
  ///
  /// > Ensure that there are no unsaved changes in the index before
  /// > beginning any operation that reloads the index from disk (eg,
  /// > checkout).  If there are unsaved changes, the instruction will
  /// > fail.  (Using the FORCE flag to checkout will still overwrite
  /// > these changes.)
  ///
  /// opts(GIT_OPT_GET_PACK_MAX_OBJECTS, size_t *out)
  ///
  /// > Get the maximum number of objects libgit2 will allow in a pack
  /// > file when downloading a pack file from a remote. This can be
  /// > used to limit maximum memory usage when fetching from an untrusted
  /// > remote.
  ///
  /// opts(GIT_OPT_SET_PACK_MAX_OBJECTS, size_t objects)
  ///
  /// > Set the maximum number of objects libgit2 will allow in a pack
  /// > file when downloading a pack file from a remote.
  ///
  /// opts(GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS, int enabled)
  /// > This will cause .keep file existence checks to be skipped when
  /// > accessing packfiles, which can help performance with remote filesystems.
  ///
  /// opts(GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE, int enabled)
  /// > When connecting to a server using NTLM or Negotiate
  /// > authentication, use expect/continue when POSTing data.
  /// > This option is not available on Windows.
  ///
  /// opts(GIT_OPT_SET_ODB_PACKED_PRIORITY, int priority)
  /// > Override the default priority of the packed ODB backend which
  /// > is added when default backends are assigned to a repository
  ///
  /// opts(GIT_OPT_SET_ODB_LOOSE_PRIORITY, int priority)
  /// > Override the default priority of the loose ODB backend which
  /// > is added when default backends are assigned to a repository
  ///
  /// opts(GIT_OPT_GET_EXTENSIONS, git_strarray *out)
  /// > Returns the list of git extensions that are supported.  This
  /// > is the list of built-in extensions supported by libgit2 and
  /// > custom extensions that have been added with
  /// > `GIT_OPT_SET_EXTENSIONS`.  Extensions that have been negated
  /// > will not be returned.  The returned list should be released
  /// > with `git_strarray_dispose`.
  ///
  /// opts(GIT_OPT_SET_EXTENSIONS, const char **extensions, size_t len)
  /// > Set that the given git extensions are supported by the caller.
  /// > Extensions supported by libgit2 may be negated by prefixing
  /// > them with a `!`.  For example: setting extensions to
  /// > { "!noop", "newext" } indicates that the caller does not want
  /// > to support repositories with the `noop` extension but does want
  /// > to support repositories with the `newext` extension.
  ///
  /// opts(GIT_OPT_GET_OWNER_VALIDATION, int *enabled)
  /// > Gets the owner validation setting for repository
  /// > directories.
  ///
  /// opts(GIT_OPT_SET_OWNER_VALIDATION, int enabled)
  /// > Set that repository directories should be owned by the current
  /// > user. The default is to validate ownership.
  ///
  /// opts(GIT_OPT_GET_HOMEDIR, git_buf *out)
  /// > Gets the current user's home directory, as it will be used
  /// > for file lookups. The path is written to the `out` buffer.
  ///
  /// opts(GIT_OPT_SET_HOMEDIR, const char *path)
  /// > Sets the directory used as the current user's home directory,
  /// > for file lookups.
  /// >
  /// > - `path` directory of home directory.
  ///
  /// opts(GIT_OPT_GET_SERVER_CONNECT_TIMEOUT, int *timeout)
  /// > Gets the timeout (in milliseconds) to attempt connections to
  /// > a remote server.
  ///
  /// opts(GIT_OPT_SET_SERVER_CONNECT_TIMEOUT, int timeout)
  /// > Sets the timeout (in milliseconds) to attempt connections to
  /// > a remote server. Set to 0 to use the system default. Note that
  /// > this may not be able to be configured longer than the system
  /// > default, typically 75 seconds.
  ///
  /// opts(GIT_OPT_GET_SERVER_TIMEOUT, int *timeout)
  /// > Gets the timeout (in milliseconds) for reading from and writing
  /// > to a remote server.
  ///
  /// opts(GIT_OPT_SET_SERVER_TIMEOUT, int timeout)
  /// > Sets the timeout (in milliseconds) for reading from and writing
  /// > to a remote server. Set to 0 to use the system default.
  ///
  /// @param option Option key
  /// @return 0 on success, <0 on failure
  int git_libgit2_opts(
    int option,
    ffi.Pointer<ffi.Char> va,
    ffi.Pointer<ffi.Char> va$1,
  ) {
    return _git_libgit2_opts(option, va, va$1);
  }

  late final _git_libgit2_optsPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Int,
            ffi.VarArgs<(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>,
          )
        >
      >('git_libgit2_opts');
  late final _git_libgit2_opts = _git_libgit2_optsPtr
      .asFunction<
        int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)
      >();

  /// Format a git_oid into a statically allocated c-string.
  ///
  /// The c-string is owned by the library and should not be freed
  /// by the user. If libgit2 is built with thread support, the string
  /// will be stored in TLS (i.e. one buffer per thread) to allow for
  /// concurrent calls of the function.
  ///
  /// @param oid The oid structure to format
  /// @return the c-string or NULL on failure
  ffi.Pointer<ffi.Char> git_oid_tostr_s(ffi.Pointer<git_oid> oid) {
    return _git_oid_tostr_s(oid);
  }

  late final _git_oid_tostr_sPtr =
      _lookup<
        ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_oid>)>
      >('git_oid_tostr_s');
  late final _git_oid_tostr_s = _git_oid_tostr_sPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_oid>)>();

  /// Close an open commit
  ///
  /// This is a wrapper around git_object_free()
  ///
  /// IMPORTANT:
  /// It *is* necessary to call this method when you stop
  /// using a commit. Failure to do so will cause a memory leak.
  ///
  /// @param commit the commit to close
  void git_commit_free(ffi.Pointer<git_commit> commit) {
    return _git_commit_free(commit);
  }

  late final _git_commit_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_commit>)>>(
        'git_commit_free',
      );
  late final _git_commit_free = _git_commit_freePtr
      .asFunction<void Function(ffi.Pointer<git_commit>)>();

  /// Get the id of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return object identity for the commit.
  ffi.Pointer<git_oid> git_commit_id(ffi.Pointer<git_commit> commit) {
    return _git_commit_id(commit);
  }

  late final _git_commit_idPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(ffi.Pointer<git_commit>)
        >
      >('git_commit_id');
  late final _git_commit_id = _git_commit_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_commit>)>();

  /// Open a git repository.
  ///
  /// The 'path' argument must point to either a git repository
  /// folder, or an existing work dir.
  ///
  /// The method will automatically detect if 'path' is a normal
  /// or bare repository or fail is 'path' is neither.
  ///
  /// Note that the libgit2 library _must_ be initialized using
  /// `git_libgit2_init` before any APIs can be called, including
  /// this one.
  ///
  /// @param[out] out pointer to the repo which will be opened
  /// @param path the path to the repository
  /// @return 0 or an error code
  int git_repository_open(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_repository_open(out, path);
  }

  late final _git_repository_openPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<ffi.Pointer<git_repository>>,
            ffi.Pointer<ffi.Char>,
          )
        >
      >('git_repository_open');
  late final _git_repository_open = _git_repository_openPtr
      .asFunction<
        int Function(
          ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<ffi.Char>,
        )
      >();

  /// Retrieve and resolve the reference pointed at by HEAD.
  ///
  /// The returned `git_reference` will be owned by caller and
  /// `git_reference_free()` must be called when done with it to release the
  /// allocated memory and prevent a leak.
  ///
  /// @param[out] out pointer to the reference which will be retrieved
  /// @param repo a repository object
  ///
  /// @return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
  /// branch, GIT_ENOTFOUND when HEAD is missing; an error code otherwise
  int git_repository_head(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_head(out, repo);
  }

  late final _git_repository_headPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<ffi.Pointer<git_reference>>,
            ffi.Pointer<git_repository>,
          )
        >
      >('git_repository_head');
  late final _git_repository_head = _git_repository_headPtr
      .asFunction<
        int Function(
          ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>,
        )
      >();

  /// Free the given reference.
  ///
  /// @param ref git_reference
  void git_reference_free(ffi.Pointer<git_reference> ref) {
    return _git_reference_free(ref);
  }

  late final _git_reference_freePtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_reference>)>
      >('git_reference_free');
  late final _git_reference_free = _git_reference_freePtr
      .asFunction<void Function(ffi.Pointer<git_reference>)>();

  /// Recursively peel reference until object of the specified type is found.
  ///
  /// The retrieved `peeled` object is owned by the repository
  /// and should be closed with the `git_object_free` method.
  ///
  /// If you pass `GIT_OBJECT_ANY` as the target type, then the object
  /// will be peeled until a non-tag object is met.
  ///
  /// @param[out] out Pointer to the peeled git_object
  /// @param ref The reference to be processed
  /// @param type The type of the requested object (GIT_OBJECT_COMMIT,
  /// GIT_OBJECT_TAG, GIT_OBJECT_TREE, GIT_OBJECT_BLOB or GIT_OBJECT_ANY).
  /// @return 0 on success, GIT_EAMBIGUOUS, GIT_ENOTFOUND or an error code
  int git_reference_peel(
    ffi.Pointer<ffi.Pointer<git_object>> out,
    ffi.Pointer<git_reference> ref,
    git_object_t type,
  ) {
    return _git_reference_peel(out, ref, type.value);
  }

  late final _git_reference_peelPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<ffi.Pointer<git_object>>,
            ffi.Pointer<git_reference>,
            ffi.Int,
          )
        >
      >('git_reference_peel');
  late final _git_reference_peel = _git_reference_peelPtr
      .asFunction<
        int Function(
          ffi.Pointer<ffi.Pointer<git_object>>,
          ffi.Pointer<git_reference>,
          int,
        )
      >();

  /// Get the reference's short name
  ///
  /// This will transform the reference name into a name "human-readable"
  /// version. If no shortname is appropriate, it will return the full
  /// name.
  ///
  /// The memory is owned by the reference and must not be freed.
  ///
  /// @param ref a reference
  /// @return the human-readable version of the name
  ffi.Pointer<ffi.Char> git_reference_shorthand(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_shorthand(ref);
  }

  late final _git_reference_shorthandPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_reference>)
        >
      >('git_reference_shorthand');
  late final _git_reference_shorthand = _git_reference_shorthandPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_reference>)>();

  /// Get the information for a particular remote
  ///
  /// The name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param out pointer to the new remote object
  /// @param repo the associated repository
  /// @param name the remote's name
  /// @return 0, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code
  int git_remote_lookup(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_remote_lookup(out, repo, name);
  }

  late final _git_remote_lookupPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<ffi.Pointer<git_remote>>,
            ffi.Pointer<git_repository>,
            ffi.Pointer<ffi.Char>,
          )
        >
      >('git_remote_lookup');
  late final _git_remote_lookup = _git_remote_lookupPtr
      .asFunction<
        int Function(
          ffi.Pointer<ffi.Pointer<git_remote>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
        )
      >();

  /// Get the remote's url
  ///
  /// If url.*.insteadOf has been configured for this URL, it will return
  /// the modified URL. This function does not consider if a push url has
  /// been configured for this remote (use `git_remote_pushurl` if needed).
  ///
  /// @param remote the remote
  /// @return a pointer to the url
  ffi.Pointer<ffi.Char> git_remote_url(ffi.Pointer<git_remote> remote) {
    return _git_remote_url(remote);
  }

  late final _git_remote_urlPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_remote>)
        >
      >('git_remote_url');
  late final _git_remote_url = _git_remote_urlPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_remote>)>();

  /// Free the memory associated with a remote
  ///
  /// This also disconnects from the remote, if the connection
  /// has not been closed yet (using git_remote_disconnect).
  ///
  /// @param remote the remote to free
  void git_remote_free(ffi.Pointer<git_remote> remote) {
    return _git_remote_free(remote);
  }

  late final _git_remote_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_remote>)>>(
        'git_remote_free',
      );
  late final _git_remote_free = _git_remote_freePtr
      .asFunction<void Function(ffi.Pointer<git_remote>)>();

  /// Initializes a `git_remote_callbacks` with default values. Equivalent to
  /// creating an instance with GIT_REMOTE_CALLBACKS_INIT.
  ///
  /// @param opts the `git_remote_callbacks` struct to initialize
  /// @param version Version of struct; pass `GIT_REMOTE_CALLBACKS_VERSION`
  /// @return Zero on success; -1 on failure.
  int git_remote_init_callbacks(
    ffi.Pointer<git_remote_callbacks> opts,
    int version,
  ) {
    return _git_remote_init_callbacks(opts, version);
  }

  late final _git_remote_init_callbacksPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote_callbacks>, ffi.UnsignedInt)
        >
      >('git_remote_init_callbacks');
  late final _git_remote_init_callbacks = _git_remote_init_callbacksPtr
      .asFunction<int Function(ffi.Pointer<git_remote_callbacks>, int)>();

  /// Clone a remote repository.
  ///
  /// By default this creates its repository and initial remote to match
  /// git's defaults. You can use the options in the callback to
  /// customize how these are created.
  ///
  /// Note that the libgit2 library _must_ be initialized using
  /// `git_libgit2_init` before any APIs can be called, including
  /// this one.
  ///
  /// @param[out] out pointer that will receive the resulting repository object
  /// @param url the remote repository to clone
  /// @param local_path local directory to clone to
  /// @param options configuration options for the clone.  If NULL, the
  /// function works as though GIT_OPTIONS_INIT were passed.
  /// @return 0 on success, any non-zero return value from a callback
  /// function, or a negative value to indicate an error (use
  /// `git_error_last` for a detailed error message)
  int git_clone(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Char> local_path,
    ffi.Pointer<git_clone_options> options,
  ) {
    return _git_clone(out, url, local_path, options);
  }

  late final _git_clonePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<ffi.Pointer<git_repository>>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<git_clone_options>,
          )
        >
      >('git_clone');
  late final _git_clone = _git_clonePtr
      .asFunction<
        int Function(
          ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_clone_options>,
        )
      >();

  /// Return the last `git_error` object that was generated for the
  /// current thread.
  ///
  /// This function will never return NULL.
  ///
  /// Callers should not rely on this to determine whether an error has
  /// occurred. For error checking, callers should examine the return
  /// codes of libgit2 functions.
  ///
  /// This call can only reliably report error messages when an error
  /// has occurred. (It may contain stale information if it is called
  /// after a different function that succeeds.)
  ///
  /// The memory for this object is managed by libgit2. It should not
  /// be freed.
  ///
  /// @return A pointer to a `git_error` object that describes the error.
  ffi.Pointer<git_error> git_error_last() {
    return _git_error_last();
  }

  late final _git_error_lastPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<git_error> Function()>>(
        'git_error_last',
      );
  late final _git_error_last = _git_error_lastPtr
      .asFunction<ffi.Pointer<git_error> Function()>();

  int git_cred_userpass_plaintext_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> password,
  ) {
    return _git_cred_userpass_plaintext_new(out, username, password);
  }

  late final _git_cred_userpass_plaintext_newPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<ffi.Pointer<git_credential>>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
          )
        >
      >('git_cred_userpass_plaintext_new');
  late final _git_cred_userpass_plaintext_new =
      _git_cred_userpass_plaintext_newPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
            )
          >();

  int git_cred_ssh_key_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> publickey,
    ffi.Pointer<ffi.Char> privatekey,
    ffi.Pointer<ffi.Char> passphrase,
  ) {
    return _git_cred_ssh_key_new(
      out,
      username,
      publickey,
      privatekey,
      passphrase,
    );
  }

  late final _git_cred_ssh_key_newPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<ffi.Pointer<git_credential>>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
          )
        >
      >('git_cred_ssh_key_new');
  late final _git_cred_ssh_key_new = _git_cred_ssh_key_newPtr
      .asFunction<
        int Function(
          ffi.Pointer<ffi.Pointer<git_credential>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
        )
      >();

  int git_clone_init_options(ffi.Pointer<git_clone_options> opts, int version) {
    return _git_clone_init_options(opts, version);
  }

  late final _git_clone_init_optionsPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_clone_options>, ffi.UnsignedInt)
        >
      >('git_clone_init_options');
  late final _git_clone_init_options = _git_clone_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_clone_options>, int)>();

  int git_fetch_init_options(ffi.Pointer<git_fetch_options> opts, int version) {
    return _git_fetch_init_options(opts, version);
  }

  late final _git_fetch_init_optionsPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_fetch_options>, ffi.UnsignedInt)
        >
      >('git_fetch_init_options');
  late final _git_fetch_init_options = _git_fetch_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_fetch_options>, int)>();

  /// Init the global state
  ///
  /// This function must be called before any other libgit2 function in
  /// order to set up global state and threading.
  ///
  /// This function may be called multiple times - it will return the number
  /// of times the initialization has been called (including this one) that have
  /// not subsequently been shutdown.
  ///
  /// @return the number of initializations of the library, or an error code.
  int git_libgit2_init() {
    return _git_libgit2_init();
  }

  late final _git_libgit2_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('git_libgit2_init');
  late final _git_libgit2_init = _git_libgit2_initPtr
      .asFunction<int Function()>();
}

/// Global library options
///
/// These are used to select which global option to set or get and are
/// used in `git_libgit2_opts()`.
enum git_libgit2_opt_t {
  GIT_OPT_GET_MWINDOW_SIZE(0),
  GIT_OPT_SET_MWINDOW_SIZE(1),
  GIT_OPT_GET_MWINDOW_MAPPED_LIMIT(2),
  GIT_OPT_SET_MWINDOW_MAPPED_LIMIT(3),
  GIT_OPT_GET_SEARCH_PATH(4),
  GIT_OPT_SET_SEARCH_PATH(5),
  GIT_OPT_SET_CACHE_OBJECT_LIMIT(6),
  GIT_OPT_SET_CACHE_MAX_SIZE(7),
  GIT_OPT_ENABLE_CACHING(8),
  GIT_OPT_GET_CACHED_MEMORY(9),
  GIT_OPT_GET_TEMPLATE_PATH(10),
  GIT_OPT_SET_TEMPLATE_PATH(11),
  GIT_OPT_SET_SSL_CERT_LOCATIONS(12),
  GIT_OPT_SET_USER_AGENT(13),
  GIT_OPT_ENABLE_STRICT_OBJECT_CREATION(14),
  GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION(15),
  GIT_OPT_SET_SSL_CIPHERS(16),
  GIT_OPT_GET_USER_AGENT(17),
  GIT_OPT_ENABLE_OFS_DELTA(18),
  GIT_OPT_ENABLE_FSYNC_GITDIR(19),
  GIT_OPT_GET_WINDOWS_SHAREMODE(20),
  GIT_OPT_SET_WINDOWS_SHAREMODE(21),
  GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION(22),
  GIT_OPT_SET_ALLOCATOR(23),
  GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY(24),
  GIT_OPT_GET_PACK_MAX_OBJECTS(25),
  GIT_OPT_SET_PACK_MAX_OBJECTS(26),
  GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS(27),
  GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE(28),
  GIT_OPT_GET_MWINDOW_FILE_LIMIT(29),
  GIT_OPT_SET_MWINDOW_FILE_LIMIT(30),
  GIT_OPT_SET_ODB_PACKED_PRIORITY(31),
  GIT_OPT_SET_ODB_LOOSE_PRIORITY(32),
  GIT_OPT_GET_EXTENSIONS(33),
  GIT_OPT_SET_EXTENSIONS(34),
  GIT_OPT_GET_OWNER_VALIDATION(35),
  GIT_OPT_SET_OWNER_VALIDATION(36),
  GIT_OPT_GET_HOMEDIR(37),
  GIT_OPT_SET_HOMEDIR(38),
  GIT_OPT_SET_SERVER_CONNECT_TIMEOUT(39),
  GIT_OPT_GET_SERVER_CONNECT_TIMEOUT(40),
  GIT_OPT_SET_SERVER_TIMEOUT(41),
  GIT_OPT_GET_SERVER_TIMEOUT(42),
  GIT_OPT_SET_USER_AGENT_PRODUCT(43),
  GIT_OPT_GET_USER_AGENT_PRODUCT(44),
  GIT_OPT_ADD_SSL_X509_CERT(45);

  final int value;
  const git_libgit2_opt_t(this.value);

  static git_libgit2_opt_t fromValue(int value) => switch (value) {
    0 => GIT_OPT_GET_MWINDOW_SIZE,
    1 => GIT_OPT_SET_MWINDOW_SIZE,
    2 => GIT_OPT_GET_MWINDOW_MAPPED_LIMIT,
    3 => GIT_OPT_SET_MWINDOW_MAPPED_LIMIT,
    4 => GIT_OPT_GET_SEARCH_PATH,
    5 => GIT_OPT_SET_SEARCH_PATH,
    6 => GIT_OPT_SET_CACHE_OBJECT_LIMIT,
    7 => GIT_OPT_SET_CACHE_MAX_SIZE,
    8 => GIT_OPT_ENABLE_CACHING,
    9 => GIT_OPT_GET_CACHED_MEMORY,
    10 => GIT_OPT_GET_TEMPLATE_PATH,
    11 => GIT_OPT_SET_TEMPLATE_PATH,
    12 => GIT_OPT_SET_SSL_CERT_LOCATIONS,
    13 => GIT_OPT_SET_USER_AGENT,
    14 => GIT_OPT_ENABLE_STRICT_OBJECT_CREATION,
    15 => GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION,
    16 => GIT_OPT_SET_SSL_CIPHERS,
    17 => GIT_OPT_GET_USER_AGENT,
    18 => GIT_OPT_ENABLE_OFS_DELTA,
    19 => GIT_OPT_ENABLE_FSYNC_GITDIR,
    20 => GIT_OPT_GET_WINDOWS_SHAREMODE,
    21 => GIT_OPT_SET_WINDOWS_SHAREMODE,
    22 => GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION,
    23 => GIT_OPT_SET_ALLOCATOR,
    24 => GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY,
    25 => GIT_OPT_GET_PACK_MAX_OBJECTS,
    26 => GIT_OPT_SET_PACK_MAX_OBJECTS,
    27 => GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS,
    28 => GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE,
    29 => GIT_OPT_GET_MWINDOW_FILE_LIMIT,
    30 => GIT_OPT_SET_MWINDOW_FILE_LIMIT,
    31 => GIT_OPT_SET_ODB_PACKED_PRIORITY,
    32 => GIT_OPT_SET_ODB_LOOSE_PRIORITY,
    33 => GIT_OPT_GET_EXTENSIONS,
    34 => GIT_OPT_SET_EXTENSIONS,
    35 => GIT_OPT_GET_OWNER_VALIDATION,
    36 => GIT_OPT_SET_OWNER_VALIDATION,
    37 => GIT_OPT_GET_HOMEDIR,
    38 => GIT_OPT_SET_HOMEDIR,
    39 => GIT_OPT_SET_SERVER_CONNECT_TIMEOUT,
    40 => GIT_OPT_GET_SERVER_CONNECT_TIMEOUT,
    41 => GIT_OPT_SET_SERVER_TIMEOUT,
    42 => GIT_OPT_GET_SERVER_TIMEOUT,
    43 => GIT_OPT_SET_USER_AGENT_PRODUCT,
    44 => GIT_OPT_GET_USER_AGENT_PRODUCT,
    45 => GIT_OPT_ADD_SSL_X509_CERT,
    _ => throw ArgumentError('Unknown value for git_libgit2_opt_t: $value'),
  };
}

/// A data buffer for exporting data from libgit2
///
/// Sometimes libgit2 wants to return an allocated data buffer to the
/// caller and have the caller take responsibility for freeing that memory.
/// To make ownership clear in these cases, libgit2 uses  `git_buf` to
/// return this data.  Callers should use `git_buf_dispose()` to release
/// the memory when they are done.
///
/// A `git_buf` contains a pointer to a NUL-terminated C string, and
/// the length of the string (not including the NUL terminator).
final class git_buf extends ffi.Struct {
  /// The buffer contents.  `ptr` points to the start of the buffer
  /// being returned.  The buffer's length (in bytes) is specified
  /// by the `size` member of the structure, and contains a NUL
  /// terminator at position `(size + 1)`.
  external ffi.Pointer<ffi.Char> ptr;

  /// This field is reserved and unused.
  @ffi.Size()
  external int reserved;

  /// The length (in bytes) of the buffer pointed to by `ptr`,
  /// not including a NUL terminator.
  @ffi.Size()
  external int size;
}

/// Unique identity of any object (commit, tree, blob, tag).
final class git_oid extends ffi.Struct {
  /// raw binary formatted id
  @ffi.Array.multi([20])
  external ffi.Array<ffi.UnsignedChar> id;
}

/// Basic type (loose or packed) of any Git object.
enum git_object_t {
  /// < Object can be any of the following
  GIT_OBJECT_ANY(-2),

  /// < Object is invalid.
  GIT_OBJECT_INVALID(-1),

  /// < A commit object.
  GIT_OBJECT_COMMIT(1),

  /// < A tree (directory listing) object.
  GIT_OBJECT_TREE(2),

  /// < A file revision object.
  GIT_OBJECT_BLOB(3),

  /// < An annotated tag object.
  GIT_OBJECT_TAG(4),

  /// < A delta, base is given by an offset.
  GIT_OBJECT_OFS_DELTA(6),

  /// < A delta, base is given by object id.
  GIT_OBJECT_REF_DELTA(7);

  final int value;
  const git_object_t(this.value);

  static git_object_t fromValue(int value) => switch (value) {
    -2 => GIT_OBJECT_ANY,
    -1 => GIT_OBJECT_INVALID,
    1 => GIT_OBJECT_COMMIT,
    2 => GIT_OBJECT_TREE,
    3 => GIT_OBJECT_BLOB,
    4 => GIT_OBJECT_TAG,
    6 => GIT_OBJECT_OFS_DELTA,
    7 => GIT_OBJECT_REF_DELTA,
    _ => throw ArgumentError('Unknown value for git_object_t: $value'),
  };
}

final class git_repository extends ffi.Opaque {}

final class git_object extends ffi.Opaque {}

final class git_commit extends ffi.Opaque {}

final class git_tree extends ffi.Opaque {}

final class git_index extends ffi.Opaque {}

final class git_reference extends ffi.Opaque {}

final class git_refspec extends ffi.Opaque {}

final class git_remote extends ffi.Opaque {}

final class git_transport extends ffi.Opaque {}

/// Argument to the completion callback which tells it which operation
/// finished.
enum git_remote_completion_t {
  GIT_REMOTE_COMPLETION_DOWNLOAD(0),
  GIT_REMOTE_COMPLETION_INDEXING(1),
  GIT_REMOTE_COMPLETION_ERROR(2);

  final int value;
  const git_remote_completion_t(this.value);

  static git_remote_completion_t fromValue(int value) => switch (value) {
    0 => GIT_REMOTE_COMPLETION_DOWNLOAD,
    1 => GIT_REMOTE_COMPLETION_INDEXING,
    2 => GIT_REMOTE_COMPLETION_ERROR,
    _ => throw ArgumentError(
      'Unknown value for git_remote_completion_t: $value',
    ),
  };
}

/// Supported credential types
///
/// This represents the various types of authentication methods supported by
/// the library.
enum git_credential_t {
  /// A vanilla user/password request
  /// @see git_credential_userpass_plaintext_new
  GIT_CREDENTIAL_USERPASS_PLAINTEXT(1),

  /// An SSH key-based authentication request
  /// @see git_credential_ssh_key_new
  GIT_CREDENTIAL_SSH_KEY(2),

  /// An SSH key-based authentication request, with a custom signature
  /// @see git_credential_ssh_custom_new
  GIT_CREDENTIAL_SSH_CUSTOM(4),

  /// An NTLM/Negotiate-based authentication request.
  /// @see git_credential_default
  GIT_CREDENTIAL_DEFAULT(8),

  /// An SSH interactive authentication request
  /// @see git_credential_ssh_interactive_new
  GIT_CREDENTIAL_SSH_INTERACTIVE(16),

  /// Username-only authentication request
  ///
  /// Used as a pre-authentication step if the underlying transport
  /// (eg. SSH, with no username in its URL) does not know which username
  /// to use.
  ///
  /// @see git_credential_username_new
  GIT_CREDENTIAL_USERNAME(32),

  /// An SSH key-based authentication request
  ///
  /// Allows credentials to be read from memory instead of files.
  /// Note that because of differences in crypto backend support, it might
  /// not be functional.
  ///
  /// @see git_credential_ssh_key_memory_new
  GIT_CREDENTIAL_SSH_MEMORY(64);

  final int value;
  const git_credential_t(this.value);

  static git_credential_t fromValue(int value) => switch (value) {
    1 => GIT_CREDENTIAL_USERPASS_PLAINTEXT,
    2 => GIT_CREDENTIAL_SSH_KEY,
    4 => GIT_CREDENTIAL_SSH_CUSTOM,
    8 => GIT_CREDENTIAL_DEFAULT,
    16 => GIT_CREDENTIAL_SSH_INTERACTIVE,
    32 => GIT_CREDENTIAL_USERNAME,
    64 => GIT_CREDENTIAL_SSH_MEMORY,
    _ => throw ArgumentError('Unknown value for git_credential_t: $value'),
  };
}

/// The base structure for all credential types
final class git_credential extends ffi.Struct {
  /// < A type of credential
  @ffi.UnsignedInt()
  external int credtypeAsInt;

  git_credential_t get credtype => git_credential_t.fromValue(credtypeAsInt);

  /// The deallocator for this type of credentials
  external ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_credential> cred)>
  >
  free;
}

/// Type of host certificate structure that is passed to the check callback
enum git_cert_t {
  /// No information about the certificate is available. This may
  /// happen when using curl.
  GIT_CERT_NONE(0),

  /// The `data` argument to the callback will be a pointer to
  /// the DER-encoded data.
  GIT_CERT_X509(1),

  /// The `data` argument to the callback will be a pointer to a
  /// `git_cert_hostkey` structure.
  GIT_CERT_HOSTKEY_LIBSSH2(2),

  /// The `data` argument to the callback will be a pointer to a
  /// `git_strarray` with `name:content` strings containing
  /// information about the certificate. This is used when using
  /// curl.
  GIT_CERT_STRARRAY(3);

  final int value;
  const git_cert_t(this.value);

  static git_cert_t fromValue(int value) => switch (value) {
    0 => GIT_CERT_NONE,
    1 => GIT_CERT_X509,
    2 => GIT_CERT_HOSTKEY_LIBSSH2,
    3 => GIT_CERT_STRARRAY,
    _ => throw ArgumentError('Unknown value for git_cert_t: $value'),
  };
}

/// Parent type for `git_cert_hostkey` and `git_cert_x509`.
final class git_cert extends ffi.Struct {
  /// Type of certificate. A `GIT_CERT_` value.
  @ffi.UnsignedInt()
  external int cert_typeAsInt;

  git_cert_t get cert_type => git_cert_t.fromValue(cert_typeAsInt);
}

/// This structure is used to provide callers information about the
/// progress of indexing a packfile, either directly or part of a
/// fetch or clone that downloads a packfile.
final class git_indexer_progress extends ffi.Struct {
  /// number of objects in the packfile being indexed
  @ffi.UnsignedInt()
  external int total_objects;

  /// received objects that have been hashed
  @ffi.UnsignedInt()
  external int indexed_objects;

  /// received_objects: objects which have been downloaded
  @ffi.UnsignedInt()
  external int received_objects;

  /// locally-available objects that have been injected in order
  /// to fix a thin pack
  @ffi.UnsignedInt()
  external int local_objects;

  /// number of deltas in the packfile being indexed
  @ffi.UnsignedInt()
  external int total_deltas;

  /// received deltas that have been indexed
  @ffi.UnsignedInt()
  external int indexed_deltas;

  /// size of the packfile received up to now
  @ffi.Size()
  external int received_bytes;
}

/// Represents an update which will be performed on the remote during push
final class git_push_update extends ffi.Struct {
  /// The source name of the reference
  external ffi.Pointer<ffi.Char> src_refname;

  /// The name of the reference to update on the server
  external ffi.Pointer<ffi.Char> dst_refname;

  /// The current target of the reference
  external git_oid src;

  /// The new target for the reference
  external git_oid dst;
}

/// The callback settings structure
///
/// Set the callbacks to be called by the remote when informing the user
/// about the progress of the network operations.
final class git_remote_callbacks extends ffi.Struct {
  /// < The version
  @ffi.UnsignedInt()
  external int version;

  /// Textual progress from the remote. Text send over the
  /// progress side-band will be passed to this function (this is
  /// the 'counting objects' output).
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Char> str,
        ffi.Int len,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  sideband_progress;

  /// Completion is called when different parts of the download
  /// process are done (currently unused).
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(ffi.UnsignedInt type, ffi.Pointer<ffi.Void> data)
    >
  >
  completion;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  ///
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Pointer<git_credential>> out,
        ffi.Pointer<ffi.Char> url,
        ffi.Pointer<ffi.Char> username_from_url,
        ffi.UnsignedInt allowed_types,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<git_cert> cert,
        ffi.Int valid,
        ffi.Pointer<ffi.Char> host,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  certificate_check;

  /// During the download of new data, this will be regularly
  /// called with the current count of progress done by the
  /// indexer.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<git_indexer_progress> stats,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  transfer_progress;

  /// Deprecated callback for reference updates, callers should
  /// set `update_refs` instead. This is retained for backward
  /// compatibility; if you specify both `update_refs` and
  /// `update_tips`, then only the `update_refs` function will
  /// be called.
  ///
  /// @deprecated the `update_refs` callback in this structure
  /// should be preferred
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Char> refname,
        ffi.Pointer<git_oid> a,
        ffi.Pointer<git_oid> b,
        ffi.Pointer<ffi.Void> data,
      )
    >
  >
  update_tips;

  /// Function to call with progress information during pack
  /// building. Be aware that this is called inline with pack
  /// building operations, so performance may be affected.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Int stage,
        ffi.Uint32 current,
        ffi.Uint32 total,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  pack_progress;

  /// Function to call with progress information during the
  /// upload portion of a push. Be aware that this is called
  /// inline with pack building operations, so performance may be
  /// affected.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.UnsignedInt current,
        ffi.UnsignedInt total,
        ffi.Size bytes,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  push_transfer_progress;

  /// See documentation of git_push_update_reference_cb
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Char> refname,
        ffi.Pointer<ffi.Char> status,
        ffi.Pointer<ffi.Void> data,
      )
    >
  >
  push_update_reference;

  /// Called once between the negotiation step and the upload. It
  /// provides information about what updates will be performed.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Pointer<git_push_update>> updates,
        ffi.Size len,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  push_negotiation;

  /// Create the transport to use for this operation. Leave NULL
  /// to auto-detect.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Pointer<git_transport>> out,
        ffi.Pointer<git_remote> owner,
        ffi.Pointer<ffi.Void> param,
      )
    >
  >
  transport;

  /// Callback when the remote is ready to connect.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<git_remote> remote,
        ffi.Int direction,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  remote_ready;

  /// This will be passed to each of the callbacks in this struct
  /// as the last parameter.
  external ffi.Pointer<ffi.Void> payload;

  /// Resolve URL before connecting to remote.
  /// The returned URL will be used to connect to the remote instead.
  ///
  /// This callback is deprecated; users should use
  /// git_remote_ready_cb and configure the instance URL instead.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<git_buf> url_resolved,
        ffi.Pointer<ffi.Char> url,
        ffi.Int direction,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  resolve_url;

  /// Each time a reference is updated locally, this function
  /// will be called with information about it. This should be
  /// preferred over the `update_tips` callback in this
  /// structure.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Char> refname,
        ffi.Pointer<git_oid> a,
        ffi.Pointer<git_oid> b,
        ffi.Pointer<git_refspec> spec,
        ffi.Pointer<ffi.Void> data,
      )
    >
  >
  update_refs;
}

/// Array of strings
final class git_strarray extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<ffi.Char>> strings;

  @ffi.Size()
  external int count;
}

/// Description of one side of a delta.
///
/// Although this is called a "file", it could represent a file, a symbolic
/// link, a submodule commit id, or even a tree (although that only if you
/// are tracking type changes or ignored/untracked directories).
final class git_diff_file extends ffi.Struct {
  /// The `git_oid` of the item.  If the entry represents an
  /// absent side of a diff (e.g. the `old_file` of a `GIT_DELTA_ADDED` delta),
  /// then the oid will be zeroes.
  external git_oid id;

  /// The NUL-terminated path to the entry relative to the working
  /// directory of the repository.
  external ffi.Pointer<ffi.Char> path;

  /// The size of the entry in bytes.
  @ffi.Uint64()
  external int size;

  /// A combination of the `git_diff_flag_t` types
  @ffi.Uint32()
  external int flags;

  /// Roughly, the stat() `st_mode` value for the item.  This will
  /// be restricted to one of the `git_filemode_t` values.
  @ffi.Uint16()
  external int mode;

  /// Represents the known length of the `id` field, when
  /// converted to a hex string.  It is generally `GIT_OID_SHA1_HEXSIZE`, unless this
  /// delta was created from reading a patch file, in which case it may be
  /// abbreviated to something reasonable, like 7 characters.
  @ffi.Uint16()
  external int id_abbrev;
}

/// Checkout notification flags
///
/// Checkout will invoke an options notification callback (`notify_cb`) for
/// certain cases - you pick which ones via `notify_flags`:
///
/// Returning a non-zero value from this callback will cancel the checkout.
/// The non-zero return value will be propagated back and returned by the
/// git_checkout_... call.
///
/// Notification callbacks are made prior to modifying any files on disk,
/// so canceling on any notification will still happen prior to any files
/// being modified.
///
/// @flags
enum git_checkout_notify_t {
  GIT_CHECKOUT_NOTIFY_NONE(0),

  /// Invokes checkout on conflicting paths.
  GIT_CHECKOUT_NOTIFY_CONFLICT(1),

  /// Notifies about "dirty" files, i.e. those that do not need an update
  /// but no longer match the baseline.  Core git displays these files when
  /// checkout runs, but won't stop the checkout.
  GIT_CHECKOUT_NOTIFY_DIRTY(2),

  /// Sends notification for any file changed.
  GIT_CHECKOUT_NOTIFY_UPDATED(4),

  /// Notifies about untracked files.
  GIT_CHECKOUT_NOTIFY_UNTRACKED(8),

  /// Notifies about ignored files.
  GIT_CHECKOUT_NOTIFY_IGNORED(16),
  GIT_CHECKOUT_NOTIFY_ALL(65535);

  final int value;
  const git_checkout_notify_t(this.value);

  static git_checkout_notify_t fromValue(int value) => switch (value) {
    0 => GIT_CHECKOUT_NOTIFY_NONE,
    1 => GIT_CHECKOUT_NOTIFY_CONFLICT,
    2 => GIT_CHECKOUT_NOTIFY_DIRTY,
    4 => GIT_CHECKOUT_NOTIFY_UPDATED,
    8 => GIT_CHECKOUT_NOTIFY_UNTRACKED,
    16 => GIT_CHECKOUT_NOTIFY_IGNORED,
    65535 => GIT_CHECKOUT_NOTIFY_ALL,
    _ => throw ArgumentError('Unknown value for git_checkout_notify_t: $value'),
  };
}

/// Checkout performance-reporting structure
final class git_checkout_perfdata extends ffi.Struct {
  @ffi.Size()
  external int mkdir_calls;

  @ffi.Size()
  external int stat_calls;

  @ffi.Size()
  external int chmod_calls;
}

/// Checkout options structure
///
/// Initialize with `GIT_CHECKOUT_OPTIONS_INIT`. Alternatively, you can
/// use `git_checkout_options_init`.
///
/// @options[version] GIT_CHECKOUT_OPTIONS_VERSION
/// @options[init_macro] GIT_CHECKOUT_OPTIONS_INIT
/// @options[init_function] git_checkout_options_init
final class git_checkout_options extends ffi.Struct {
  /// < The version
  @ffi.UnsignedInt()
  external int version;

  /// < default will be a safe checkout
  @ffi.UnsignedInt()
  external int checkout_strategy;

  /// < don't apply filters like CRLF conversion
  @ffi.Int()
  external int disable_filters;

  /// < default is 0755
  @ffi.UnsignedInt()
  external int dir_mode;

  /// < default is 0644 or 0755 as dictated by blob
  @ffi.UnsignedInt()
  external int file_mode;

  /// < default is O_CREAT | O_TRUNC | O_WRONLY
  @ffi.Int()
  external int file_open_flags;

  /// Checkout notification flags specify what operations the notify
  /// callback is invoked for.
  ///
  /// @type[flags] git_checkout_notify_t
  @ffi.UnsignedInt()
  external int notify_flags;

  /// Optional callback to get notifications on specific file states.
  /// @see git_checkout_notify_t
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.UnsignedInt why,
        ffi.Pointer<ffi.Char> path,
        ffi.Pointer<git_diff_file> baseline,
        ffi.Pointer<git_diff_file> target,
        ffi.Pointer<git_diff_file> workdir,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  notify_cb;

  /// Payload passed to notify_cb
  external ffi.Pointer<ffi.Void> notify_payload;

  /// Optional callback to notify the consumer of checkout progress.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<ffi.Char> path,
        ffi.Size completed_steps,
        ffi.Size total_steps,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  progress_cb;

  /// Payload passed to progress_cb
  external ffi.Pointer<ffi.Void> progress_payload;

  /// A list of wildmatch patterns or paths.
  ///
  /// By default, all paths are processed. If you pass an array of wildmatch
  /// patterns, those will be used to filter which paths should be taken into
  /// account.
  ///
  /// Use GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as a simple list.
  external git_strarray paths;

  /// The expected content of the working directory; defaults to HEAD.
  ///
  /// If the working directory does not match this baseline information,
  /// that will produce a checkout conflict.
  external ffi.Pointer<git_tree> baseline;

  /// Like `baseline` above, though expressed as an index.  This
  /// option overrides `baseline`.
  external ffi.Pointer<git_index> baseline_index;

  /// < alternative checkout path to workdir
  external ffi.Pointer<ffi.Char> target_directory;

  /// < the name of the common ancestor side of conflicts
  external ffi.Pointer<ffi.Char> ancestor_label;

  /// < the name of the "our" side of conflicts
  external ffi.Pointer<ffi.Char> our_label;

  /// < the name of the "their" side of conflicts
  external ffi.Pointer<ffi.Char> their_label;

  /// Optional callback to notify the consumer of performance data.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<git_checkout_perfdata> perfdata,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  perfdata_cb;

  /// Payload passed to perfdata_cb
  external ffi.Pointer<ffi.Void> perfdata_payload;
}

/// The type of proxy to use.
enum git_proxy_t {
  /// Do not attempt to connect through a proxy
  ///
  /// If built against libcurl, it itself may attempt to connect
  /// to a proxy if the environment variables specify it.
  GIT_PROXY_NONE(0),

  /// Try to auto-detect the proxy from the git configuration.
  GIT_PROXY_AUTO(1),

  /// Connect via the URL given in the options
  GIT_PROXY_SPECIFIED(2);

  final int value;
  const git_proxy_t(this.value);

  static git_proxy_t fromValue(int value) => switch (value) {
    0 => GIT_PROXY_NONE,
    1 => GIT_PROXY_AUTO,
    2 => GIT_PROXY_SPECIFIED,
    _ => throw ArgumentError('Unknown value for git_proxy_t: $value'),
  };
}

/// Options for connecting through a proxy
///
/// Note that not all types may be supported, depending on the platform
/// and compilation options.
final class git_proxy_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// The type of proxy to use, by URL, auto-detect.
  @ffi.UnsignedInt()
  external int typeAsInt;

  git_proxy_t get type => git_proxy_t.fromValue(typeAsInt);

  /// The URL of the proxy.
  external ffi.Pointer<ffi.Char> url;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  ///
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Pointer<git_credential>> out,
        ffi.Pointer<ffi.Char> url,
        ffi.Pointer<ffi.Char> username_from_url,
        ffi.UnsignedInt allowed_types,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<git_cert> cert,
        ffi.Int valid,
        ffi.Pointer<ffi.Char> host,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  certificate_check;

  /// Payload to be provided to the credentials and certificate
  /// check callbacks.
  external ffi.Pointer<ffi.Void> payload;
}

/// Remote redirection settings; whether redirects to another host
/// are permitted.  By default, git will follow a redirect on the
/// initial request (`/info/refs`), but not subsequent requests.
enum git_remote_redirect_t {
  /// Do not follow any off-site redirects at any stage of
  /// the fetch or push.
  GIT_REMOTE_REDIRECT_NONE(1),

  /// Allow off-site redirects only upon the initial request.
  /// This is the default.
  GIT_REMOTE_REDIRECT_INITIAL(2),

  /// Allow redirects at any stage in the fetch or push.
  GIT_REMOTE_REDIRECT_ALL(4);

  final int value;
  const git_remote_redirect_t(this.value);

  static git_remote_redirect_t fromValue(int value) => switch (value) {
    1 => GIT_REMOTE_REDIRECT_NONE,
    2 => GIT_REMOTE_REDIRECT_INITIAL,
    4 => GIT_REMOTE_REDIRECT_ALL,
    _ => throw ArgumentError('Unknown value for git_remote_redirect_t: $value'),
  };
}

/// Acceptable prune settings when fetching
enum git_fetch_prune_t {
  /// Use the setting from the configuration
  GIT_FETCH_PRUNE_UNSPECIFIED(0),

  /// Force pruning on
  GIT_FETCH_PRUNE(1),

  /// Force pruning off
  GIT_FETCH_NO_PRUNE(2);

  final int value;
  const git_fetch_prune_t(this.value);

  static git_fetch_prune_t fromValue(int value) => switch (value) {
    0 => GIT_FETCH_PRUNE_UNSPECIFIED,
    1 => GIT_FETCH_PRUNE,
    2 => GIT_FETCH_NO_PRUNE,
    _ => throw ArgumentError('Unknown value for git_fetch_prune_t: $value'),
  };
}

/// Automatic tag following option
///
/// Lets us select the --tags option to use.
enum git_remote_autotag_option_t {
  /// Use the setting from the configuration.
  GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED(0),

  /// Ask the server for tags pointing to objects we're already
  /// downloading.
  GIT_REMOTE_DOWNLOAD_TAGS_AUTO(1),

  /// Don't ask for any tags beyond the refspecs.
  GIT_REMOTE_DOWNLOAD_TAGS_NONE(2),

  /// Ask for the all the tags.
  GIT_REMOTE_DOWNLOAD_TAGS_ALL(3);

  final int value;
  const git_remote_autotag_option_t(this.value);

  static git_remote_autotag_option_t fromValue(int value) => switch (value) {
    0 => GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED,
    1 => GIT_REMOTE_DOWNLOAD_TAGS_AUTO,
    2 => GIT_REMOTE_DOWNLOAD_TAGS_NONE,
    3 => GIT_REMOTE_DOWNLOAD_TAGS_ALL,
    _ => throw ArgumentError(
      'Unknown value for git_remote_autotag_option_t: $value',
    ),
  };
}

/// Fetch options structure.
///
/// Zero out for defaults.  Initialize with `GIT_FETCH_OPTIONS_INIT` macro to
/// correctly set the `version` field.  E.g.
///
/// git_fetch_options opts = GIT_FETCH_OPTIONS_INIT;
final class git_fetch_options extends ffi.Struct {
  @ffi.Int()
  external int version;

  /// Callbacks to use for this fetch operation
  external git_remote_callbacks callbacks;

  /// Whether to perform a prune after the fetch
  @ffi.UnsignedInt()
  external int pruneAsInt;

  git_fetch_prune_t get prune => git_fetch_prune_t.fromValue(pruneAsInt);

  /// How to handle reference updates; see `git_remote_update_flags`.
  @ffi.UnsignedInt()
  external int update_fetchhead;

  /// Determines how to behave regarding tags on the remote, such
  /// as auto-downloading tags for objects we're downloading or
  /// downloading all of them.
  ///
  /// The default is to auto-follow tags.
  @ffi.UnsignedInt()
  external int download_tagsAsInt;

  git_remote_autotag_option_t get download_tags =>
      git_remote_autotag_option_t.fromValue(download_tagsAsInt);

  /// Proxy options to use, by default no proxy is used.
  external git_proxy_options proxy_opts;

  /// Depth of the fetch to perform, or `GIT_FETCH_DEPTH_FULL`
  /// (or `0`) for full history, or `GIT_FETCH_DEPTH_UNSHALLOW`
  /// to "unshallow" a shallow repository.
  ///
  /// The default is full (`GIT_FETCH_DEPTH_FULL` or `0`).
  @ffi.Int()
  external int depth;

  /// Whether to allow off-site redirects.  If this is not
  /// specified, the `http.followRedirects` configuration setting
  /// will be consulted.
  @ffi.UnsignedInt()
  external int follow_redirectsAsInt;

  git_remote_redirect_t get follow_redirects =>
      git_remote_redirect_t.fromValue(follow_redirectsAsInt);

  /// Extra headers for this fetch operation
  external git_strarray custom_headers;
}

/// Options for bypassing the git-aware transport on clone. Bypassing
/// it means that instead of a fetch, libgit2 will copy the object
/// database directory instead of figuring out what it needs, which is
/// faster. If possible, it will hardlink the files to save space.
enum git_clone_local_t {
  /// Auto-detect (default), libgit2 will bypass the git-aware
  /// transport for local paths, but use a normal fetch for
  /// `file://` urls.
  GIT_CLONE_LOCAL_AUTO(0),

  /// Bypass the git-aware transport even for a `file://` url.
  GIT_CLONE_LOCAL(1),

  /// Do no bypass the git-aware transport
  GIT_CLONE_NO_LOCAL(2),

  /// Bypass the git-aware transport, but do not try to use
  /// hardlinks.
  GIT_CLONE_LOCAL_NO_LINKS(3);

  final int value;
  const git_clone_local_t(this.value);

  static git_clone_local_t fromValue(int value) => switch (value) {
    0 => GIT_CLONE_LOCAL_AUTO,
    1 => GIT_CLONE_LOCAL,
    2 => GIT_CLONE_NO_LOCAL,
    3 => GIT_CLONE_LOCAL_NO_LINKS,
    _ => throw ArgumentError('Unknown value for git_clone_local_t: $value'),
  };
}

/// Clone options structure
///
/// Initialize with `GIT_CLONE_OPTIONS_INIT`. Alternatively, you can
/// use `git_clone_options_init`.
///
/// @options[version] GIT_CLONE_OPTIONS_VERSION
/// @options[init_macro] GIT_CLONE_OPTIONS_INIT
/// @options[init_function] git_clone_options_init
final class git_clone_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// These options are passed to the checkout step. To disable
  /// checkout, set the `checkout_strategy` to `GIT_CHECKOUT_NONE`
  /// or `GIT_CHECKOUT_DRY_RUN`.
  external git_checkout_options checkout_opts;

  /// Options which control the fetch, including callbacks.
  ///
  /// The callbacks are used for reporting fetch progress, and for acquiring
  /// credentials in the event they are needed.
  external git_fetch_options fetch_opts;

  /// Set to zero (false) to create a standard repo, or non-zero
  /// for a bare repo
  @ffi.Int()
  external int bare;

  /// Whether to use a fetch or copy the object database.
  @ffi.UnsignedInt()
  external int localAsInt;

  git_clone_local_t get local => git_clone_local_t.fromValue(localAsInt);

  /// The name of the branch to checkout. NULL means use the
  /// remote's default branch.
  external ffi.Pointer<ffi.Char> checkout_branch;

  /// A callback used to create the new repository into which to
  /// clone. If NULL, the 'bare' field will be used to determine
  /// whether to create a bare repository.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Pointer<git_repository>> out,
        ffi.Pointer<ffi.Char> path,
        ffi.Int bare,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  repository_cb;

  /// An opaque payload to pass to the git_repository creation callback.
  /// This parameter is ignored unless repository_cb is non-NULL.
  external ffi.Pointer<ffi.Void> repository_cb_payload;

  /// A callback used to create the git_remote, prior to its being
  /// used to perform the clone operation. See the documentation for
  /// git_remote_create_cb for details. This parameter may be NULL,
  /// indicating that git_clone should provide default behavior.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Pointer<git_remote>> out,
        ffi.Pointer<git_repository> repo,
        ffi.Pointer<ffi.Char> name,
        ffi.Pointer<ffi.Char> url,
        ffi.Pointer<ffi.Void> payload,
      )
    >
  >
  remote_cb;

  /// An opaque payload to pass to the git_remote creation callback.
  /// This parameter is ignored unless remote_cb is non-NULL.
  external ffi.Pointer<ffi.Void> remote_cb_payload;
}

/// Generic return codes
enum git_error_code {
  /// No error occurred; the call was successful.
  GIT_OK(0),

  /// An error occurred; call `git_error_last` for more information.
  GIT_ERROR(-1),

  /// < Requested object could not be found.
  GIT_ENOTFOUND(-3),

  /// < Object exists preventing operation.
  GIT_EEXISTS(-4),

  /// < More than one object matches.
  GIT_EAMBIGUOUS(-5),

  /// < Output buffer too short to hold data.
  GIT_EBUFS(-6),

  /// GIT_EUSER is a special error that is never generated by libgit2
  /// code.  You can return it from a callback (e.g to stop an iteration)
  /// to know that it was generated by the callback and not by libgit2.
  GIT_EUSER(-7),

  /// < Operation not allowed on bare repository.
  GIT_EBAREREPO(-8),

  /// < HEAD refers to branch with no commits.
  GIT_EUNBORNBRANCH(-9),

  /// < Merge in progress prevented operation
  GIT_EUNMERGED(-10),

  /// < Reference was not fast-forwardable
  GIT_ENONFASTFORWARD(-11),

  /// < Name/ref spec was not in a valid format
  GIT_EINVALIDSPEC(-12),

  /// < Checkout conflicts prevented operation
  GIT_ECONFLICT(-13),

  /// < Lock file prevented operation
  GIT_ELOCKED(-14),

  /// < Reference value does not match expected
  GIT_EMODIFIED(-15),

  /// < Authentication error
  GIT_EAUTH(-16),

  /// < Server certificate is invalid
  GIT_ECERTIFICATE(-17),

  /// < Patch/merge has already been applied
  GIT_EAPPLIED(-18),

  /// < The requested peel operation is not possible
  GIT_EPEEL(-19),

  /// < Unexpected EOF
  GIT_EEOF(-20),

  /// < Invalid operation or input
  GIT_EINVALID(-21),

  /// < Uncommitted changes in index prevented operation
  GIT_EUNCOMMITTED(-22),

  /// < The operation is not valid for a directory
  GIT_EDIRECTORY(-23),

  /// < A merge conflict exists and cannot continue
  GIT_EMERGECONFLICT(-24),

  /// < A user-configured callback refused to act
  GIT_PASSTHROUGH(-30),

  /// < Signals end of iteration with iterator
  GIT_ITEROVER(-31),

  /// < Internal only
  GIT_RETRY(-32),

  /// < Hashsum mismatch in object
  GIT_EMISMATCH(-33),

  /// < Unsaved changes in the index would be overwritten
  GIT_EINDEXDIRTY(-34),

  /// < Patch application failed
  GIT_EAPPLYFAIL(-35),

  /// < The object is not owned by the current user
  GIT_EOWNER(-36),

  /// < The operation timed out
  GIT_TIMEOUT(-37),

  /// < There were no changes
  GIT_EUNCHANGED(-38),

  /// < An option is not supported
  GIT_ENOTSUPPORTED(-39),

  /// < The subject is read-only
  GIT_EREADONLY(-40);

  final int value;
  const git_error_code(this.value);

  static git_error_code fromValue(int value) => switch (value) {
    0 => GIT_OK,
    -1 => GIT_ERROR,
    -3 => GIT_ENOTFOUND,
    -4 => GIT_EEXISTS,
    -5 => GIT_EAMBIGUOUS,
    -6 => GIT_EBUFS,
    -7 => GIT_EUSER,
    -8 => GIT_EBAREREPO,
    -9 => GIT_EUNBORNBRANCH,
    -10 => GIT_EUNMERGED,
    -11 => GIT_ENONFASTFORWARD,
    -12 => GIT_EINVALIDSPEC,
    -13 => GIT_ECONFLICT,
    -14 => GIT_ELOCKED,
    -15 => GIT_EMODIFIED,
    -16 => GIT_EAUTH,
    -17 => GIT_ECERTIFICATE,
    -18 => GIT_EAPPLIED,
    -19 => GIT_EPEEL,
    -20 => GIT_EEOF,
    -21 => GIT_EINVALID,
    -22 => GIT_EUNCOMMITTED,
    -23 => GIT_EDIRECTORY,
    -24 => GIT_EMERGECONFLICT,
    -30 => GIT_PASSTHROUGH,
    -31 => GIT_ITEROVER,
    -32 => GIT_RETRY,
    -33 => GIT_EMISMATCH,
    -34 => GIT_EINDEXDIRTY,
    -35 => GIT_EAPPLYFAIL,
    -36 => GIT_EOWNER,
    -37 => GIT_TIMEOUT,
    -38 => GIT_EUNCHANGED,
    -39 => GIT_ENOTSUPPORTED,
    -40 => GIT_EREADONLY,
    _ => throw ArgumentError('Unknown value for git_error_code: $value'),
  };
}

/// Error classes are the category of error. They reflect the area of the
/// code where an error occurred.
enum git_error_t {
  GIT_ERROR_NONE(0),
  GIT_ERROR_NOMEMORY(1),
  GIT_ERROR_OS(2),
  GIT_ERROR_INVALID(3),
  GIT_ERROR_REFERENCE(4),
  GIT_ERROR_ZLIB(5),
  GIT_ERROR_REPOSITORY(6),
  GIT_ERROR_CONFIG(7),
  GIT_ERROR_REGEX(8),
  GIT_ERROR_ODB(9),
  GIT_ERROR_INDEX(10),
  GIT_ERROR_OBJECT(11),
  GIT_ERROR_NET(12),
  GIT_ERROR_TAG(13),
  GIT_ERROR_TREE(14),
  GIT_ERROR_INDEXER(15),
  GIT_ERROR_SSL(16),
  GIT_ERROR_SUBMODULE(17),
  GIT_ERROR_THREAD(18),
  GIT_ERROR_STASH(19),
  GIT_ERROR_CHECKOUT(20),
  GIT_ERROR_FETCHHEAD(21),
  GIT_ERROR_MERGE(22),
  GIT_ERROR_SSH(23),
  GIT_ERROR_FILTER(24),
  GIT_ERROR_REVERT(25),
  GIT_ERROR_CALLBACK(26),
  GIT_ERROR_CHERRYPICK(27),
  GIT_ERROR_DESCRIBE(28),
  GIT_ERROR_REBASE(29),
  GIT_ERROR_FILESYSTEM(30),
  GIT_ERROR_PATCH(31),
  GIT_ERROR_WORKTREE(32),
  GIT_ERROR_SHA(33),
  GIT_ERROR_HTTP(34),
  GIT_ERROR_INTERNAL(35),
  GIT_ERROR_GRAFTS(36);

  final int value;
  const git_error_t(this.value);

  static git_error_t fromValue(int value) => switch (value) {
    0 => GIT_ERROR_NONE,
    1 => GIT_ERROR_NOMEMORY,
    2 => GIT_ERROR_OS,
    3 => GIT_ERROR_INVALID,
    4 => GIT_ERROR_REFERENCE,
    5 => GIT_ERROR_ZLIB,
    6 => GIT_ERROR_REPOSITORY,
    7 => GIT_ERROR_CONFIG,
    8 => GIT_ERROR_REGEX,
    9 => GIT_ERROR_ODB,
    10 => GIT_ERROR_INDEX,
    11 => GIT_ERROR_OBJECT,
    12 => GIT_ERROR_NET,
    13 => GIT_ERROR_TAG,
    14 => GIT_ERROR_TREE,
    15 => GIT_ERROR_INDEXER,
    16 => GIT_ERROR_SSL,
    17 => GIT_ERROR_SUBMODULE,
    18 => GIT_ERROR_THREAD,
    19 => GIT_ERROR_STASH,
    20 => GIT_ERROR_CHECKOUT,
    21 => GIT_ERROR_FETCHHEAD,
    22 => GIT_ERROR_MERGE,
    23 => GIT_ERROR_SSH,
    24 => GIT_ERROR_FILTER,
    25 => GIT_ERROR_REVERT,
    26 => GIT_ERROR_CALLBACK,
    27 => GIT_ERROR_CHERRYPICK,
    28 => GIT_ERROR_DESCRIBE,
    29 => GIT_ERROR_REBASE,
    30 => GIT_ERROR_FILESYSTEM,
    31 => GIT_ERROR_PATCH,
    32 => GIT_ERROR_WORKTREE,
    33 => GIT_ERROR_SHA,
    34 => GIT_ERROR_HTTP,
    35 => GIT_ERROR_INTERNAL,
    36 => GIT_ERROR_GRAFTS,
    _ => throw ArgumentError('Unknown value for git_error_t: $value'),
  };
}

/// Structure to store extra details of the last error that occurred.
///
/// This is kept on a per-thread basis if GIT_THREADS was defined when the
/// library was build, otherwise one is kept globally for the library
final class git_error extends ffi.Struct {
  /// < The error message for the last error.
  external ffi.Pointer<ffi.Char> message;

  /// < The category of the last error. @type git_error_t
  @ffi.Int()
  external int klass;
}
